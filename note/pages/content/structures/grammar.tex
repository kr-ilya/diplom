\subsection{Разработка грамматики языка}

Описание языка программирования основывается на теории формальных языков.
В данном разделе проводится разработка формальной грамматики языка.


\subsubsection{Способы задания языков}

Для задания языка можно воспользоваться следующими методами:

\begin{enumerate}
    \item перечислить все цепочки языка;
    \item указать способ порождения цепочек;
    \item определить метод распознавания допустимых цепочек.
\end{enumerate}

Перечисление всех цепочек языка возможно в исключительных случаях, например,
когда для управления некоторой системой достаточно двух-трех команд.

Механизм порождения цепочек предполагает использование формальной порождающей грамматики.

Формальная порождающая грамматикиа -- это математиечская система, описывающая правила построения цепочек некоторого (формального) языка.

Распознавание допустимых цепочек осуществляется с помощью некоторого логического устройства -- распознавателя.
На вход распознавателя подается цепочка, а на выходе образуется логическое значение <<истина>> в случае принадлежности цепочки языку
и <<ложь>>, если цепочка языку не принадлежит.
Распознаватели строятся на основе теорий конечных автоматов и автоматов с магазинной памятью.

Методы порождения и распознавания тесно связаны.
Механизм порождения обычно используется при описании языка, а распозанватель при его реализации, т.е. в трансляторе.

Описать синтаксис языков программирования можно несколькими способами, например, такими как формы Бэкуса-Наура, диаграммы Вирта и другими.
Это методы задают правила вывода, определяющие возможные конструкции цепочек языка.
В данном проекте для описания грамматики языка используется расширенная форма Бэкуса-Наура (РБНФ).



\subsubsection{Применение расширенной формы Бэкуса-Наура для описания формальной грамматики языка}

Расширенная форма Бэкуса-Наура – формальная система определения синтаксиса,
в которой одни синтаксические категории последовательно определяются через другие.
Используется для описания контекстно-свободных грамматик.

Формальная грамматика задаётся четвёркой вида:

\(G = (V_T, V_N, P, S)\),

где \(V_T\) -- множество терминальных символов грамматики – конечные
элементы языка, не разбирающиеся на более мелкие составляющие в рамках
синтаксического анализа, например ключевые слова, цифры, буквы
латинского алфавита.

\(V_N\) -- конечное множество нетерминальных символов – элементов грамматики, имеющих собственные имена и структуру.
Каждый нетерминальный символ состоит из одного или более терминальных и/или нетерминальных символов.

\(P\) -- множество правил вывода грамматики.

\(S\) -- начальный символ грамматики, \(S \in V_N\).

РБНФ является одним из видов формальных грамматик.
РБНФ состоит из множества правил вывода, каждое из которых определяет синтаксис некоторой конструкции языка.

Некоторые основные конструкции РБНФ:

\begin{itemize}
    \item A, B -- конкатенация элементов;
    \item A | B -- выбор (A или B);
    \item {[A]} -- элемент в квадратных скобках может отсутствовать (аналог - <<?>>);
    \item \{A\} -- повторение элемента 0 или более раз (аналог - <<*>>);
    \item (A B) -- группировка элементов;
    \item (* … *) – комментарий;
    \item <<;>> – отмечает окончание правила (аналог - <<.>>).
\end{itemize}

Кроме того, в качестве синтаксического сахара могут использоваться следующие символы:

\begin{itemize}
    \item <<*>> - предыдущий элемент может встречаться 0 или более раз;
    \item <<?>> - предыдущий элемент является необязательным (присутствует 0 или 1 раз);
    \item <<+>> - предыдущий элемент встречается 1 или более раз.
\end{itemize}

В соответствии с данными правилами описание синтаксиса предметно-ориентированного языка будет выглядеть следующим образом:

Program = Statement+ \\

Statement = AssignStmt | FunctionDecl | ExpressionStmt | ReturnStmt | BlockStmt | IfStmt .

ExpressionStmt = Expression .

Identifier = (letter | "{}\_"{}) { letter | "{}\_"{} | digit } . \\

Expression = UnaryExpr | Expression binary\_op Expression . 

UnaryExpr = PrimaryExpr | unary\_op UnaryExpr . \\

PrimaryExpr = Operand | PrimaryExpr Index | CallExpr .

Index = "{}["{} Expression "{}]"{} . \\

AssignStmt = Identifier assign\_op Expression .

ReturnStmt = "{}return"{} [Expression] .

BlockStmt = "{}\{"{} StatementList "{}\}" .

StatementList = \{ Statement "{};"{} \} . \\

IfStmt = "{}if("{} [Expression] "{})"{} BlockStmt ["{}else"{} BlockStmt] . \\

FunctionDecl = "{}fn("{} [ParameterList] "{})"{} BlockStmt .

ParameterList = Identifier \{ "{},"{} Identifier \} .

Arguments = "{}("{} [ ExpressionList ] "{})"{} . \\

CallExpr = Identifier Arguments .

ExpressionList = Expression \{ "{},"{} Expression \} . \\

Array = "{}["{} [ ExpressionList ] "{}]"{} . \\

Key = stringLiteral | intLiteral | Identifier | Expression .

KeyedElement  = [ Key "{}:"{} Expression ] .

Map = "{}\{"{} KeyedElement \{ "{},"{} KeyedElement \} "{}\}"{} . \\

Operand = Literal | "{}("{} Expression "{})"{} .

Literal = intLiteral | stringLiteral | Array | Map .

intLiteral = digit \{ digit \} .

stringLiteral = << "{} >> \{ ascii\_char \} << "{} >> . \\

binary\_op = "{}||"{} | "{}\&\&"{} | rel\_op | add\_op | mul\_op .

rel\_op = "{}=="{} | "{}!="{} | \"{}<\"{} | "{}<="{} | "{}>"{} | "{}>="{} .

add\_op = "{}+"{} | "{}-"{} .

mul\_op = "{}*"{} | "{}/"{} | "{}\%"{} .

assign\_op = "{}="{} . \\

unary\_op = "{}-"{} | "{}!"{} . \\

digit = "{}0"{} ... "{}9"{} .

letter = "{}A"{} ... "{}Z"{} | "{}a"{} ... "{}z"{} .

ascii\_char = (* ascii character *) . \\

Начальное состояние, с которого начинается разбор -- Program.

В данном разделе была разработана и описана с помощью расширенной формы Бэкуса-Наура формальная грамматика предметно-ориентированного языка.